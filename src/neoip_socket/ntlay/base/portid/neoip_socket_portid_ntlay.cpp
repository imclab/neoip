/*! \file
    \brief definition of the \ref socket_portid_ntlay_t
*/

/* system include */
/* local include */
#include "neoip_socket_portid_ntlay.hpp"

NEOIP_NAMESPACE_BEGIN

// define and insert this product into the factory plant
FACTORY_PRODUCT_DEFINITION(socket_portid_vapi_t, socket_portid_ntlay_t);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//                     ctor/dtor
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

/** \brief set from a string
 */
socket_err_t	socket_portid_ntlay_t::ctor_from_str(const std::string &str)	throw()
{
	// parse the input
	ntudp_portid	= str;
	// if the ntudp_portid is now null, it means the parsing failed
	if( ntudp_portid.is_null() )	return socket_err_t::ERROR;
	// return no error
	return socket_err_t::OK;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//                    query function
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

/** \brief return the domain of this address
 */
socket_domain_t socket_portid_ntlay_t::get_domain()	const throw()
{
	return socket_domain_t::NTLAY;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//                        main comparison function
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

/** \brief compare 2 \ref socket_portid_ntlay_t
 */
int	socket_portid_ntlay_t::compare(const socket_portid_vapi_t &other_api)	const throw()
{
	// sanity check - both MUST have the same type
	DBG_ASSERT( typeid(*this) == typeid(other_api) );
	// cast the base class into the derived one
	const socket_portid_ntlay_t &other = dynamic_cast <const socket_portid_ntlay_t&>(other_api);

	// compare the ntudp_portid
	if( ntudp_portid < other.ntudp_portid )		return -1;
	if( ntudp_portid > other.ntudp_portid )		return +1;
	// NOTE: here both are considered equal
	return 0;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//                     display function
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

/** \brief convert a string into an object
 */
std::string	socket_portid_ntlay_t::to_string()				const throw()
{
	return ntudp_portid.to_string();
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//                  serialization functions
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

/** \brief serialize the object (without the domain)
 */
void	socket_portid_ntlay_t::serialize(serial_t &serial)			const throw()
{
	serial << ntudp_portid;
}

/** \brief unserialize the object (without the domain)
 */
void	socket_portid_ntlay_t::unserialize(serial_t &serial)			throw(serial_except_t)
{
	serial >> ntudp_portid;
}
	
NEOIP_NAMESPACE_END




